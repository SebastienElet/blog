<!--VarStream
title=Les modules Javascript : Un joyeux B
description=Dès lors que l'on tente de créer des applications complexes en Javascript, la segmentation du code en divers fichiers devient nécessaire. Cela génère une nouvelle difficulté, la modularisation du Javascript.
shortTitle=Modules Javascript
shortDesc=En savoir plus sur la création de modules en Javascript
published=2012-08-17T11:34:48.000Z
lang=fr
location=FR
keywords.+=JavaScript
categories.+=.*
-->

<h2>Dès lors que l'on tente de créer des applications complexes en Javascript, la segmentation du code en divers fichiers devient nécessaire. Cela génère une nouvelle difficulté, la modularisation du Javascript.</h2>
<p>Dès lors que l'on tente de créer des applications complexes en Javascript, la segmentation
  du code en divers fichiers devient nécessaire. Cela génère une nouvelle difficulté,
  la modularisation du Javascript.</p>

<p>Il existe deux approches principales pour la création de modules Javascript, <a title="Voir la définition Wikipédia href=http://fr.wikipedia.org/wiki/CommonJS">CommonJS</a>,
  basé sur une approche synchrone du chargement de module et <abbr title="Asynchronous Module Definition lang=en">AMD</abbr>  basé sur le chargement asynchrone des modules. Voici le résultats de mes recherches
  sur le sujet.</p>
<h3>Principe de base</h3>
<p>Que ce soit côté serveur ou côté client, le contenu d'un fichier Javascript s’exécute
  dans le contexte global. L'objectif des modules est de cloisonner le code dans
  un contexte restreint (appelé scope), et d'exporter de ce contexte uniquement les
  informations nécessaires à sa bonne utilisation (closure pattern). Un exemple simple
  de ce principe :</p><pre>(function(exports){<br /> var a=1, b=2; // Création de deux variables dans le scope restreint<br /> exports.a=a; // Variable a exportée dans le scope global<br />})(window);</pre>
<p>Ce script est très basique malgré son apparence peu conventionnelle pour un développeur
  débutant en Javascript. Il crée une fonction anonyme entre parenthèse et l’exécute
  immédiatement après. L'objet window représentant le contexte global, il est passé
  en argument à cette fonction.</p>
<p>Ainsi, à l'intérieur de la fonction, le code s'exécute dans un contexte restreint
  et seules les variables ajoutées à l'objet exports seront disponibles dans le contexte
  global. A noter que par variable, étant donné la nature de Javascript, il peut
  s'agir de types natifs ou d'objets (donc aussi de fonctions).</p>
<p>Nous aurions pu passer en paramètre un autre contexte et ainsi permettre l'utilisation
  du module par un autre module.</p>
<h3>Approche synchrone (CommonJS, NodeJS)</h3>
<p>Conscients de la nécessité de modulariser le Javascript, l'initiative CommonJs a
  proposé une méthode qui est utilisée au sein de NodeJS. Les modules CommonJS proposent
  deux éléments centraux. La fonction require() qui retourne le contenu exporté au
  chargement d'un module et l'objet exports qui permet, un peu à la manière de l'exemple
  précédent, d'exporter certaines valeurs du module.</p>
<p>La <a hreflang="en title=Voir le fichier href=https://github.com/nfroidure/VarStream/blob/master/VarStreamReader.js#L344">dernière ligne du fichier VarStreamReader</a>  de mon projet VarStream montre bien comment exporter un objet (ici l'objet VarStreamReader) :</p><pre>if(!(typeof(module)=='undefined'))<br /> module.exports = VarStreamReader;</pre>
<p>La condition sert à pouvoir utiliser le fichier dans un contexte étranger à CommonJS.
  Pour charger un module, rien de plus simple, il suffit d'utiliser la fonction globale
  require() comme on peut le voir dans ce fichier qui inclus le module cité précédemment :</p>
<p>var VarStreamReader=require('./VarStreamReader');</p>
<p>Cette approche est parfaite pour le Javascript côté serveur puisque le chargement
  se fait directement à partir du disque dur. Malheureusement, celle-ci est imparfaite
  pour le chargement de modules côté client, dans un navigateur.</p>
<h3>Approche Asynchrone (AMD)</h3>
<p>L'approche synchrone dans le navigateur induit un chargement séquentiel des fichiers
  Javascript composé d'itérations successives de la séquence téléchargement + interprétation.
  Ainsi, si un module nécessite le chargement de trois autres modules (concept appelé
  dépendance), le temps nécessaire pour résoudre ces dépendances sera donc une addition
  des temps de téléchargement et d'interprétation de chacun des trois fichiers Javascript.</p>
<p>Un autre inconvénient de l'approche synchrone est qu'elle implique le chargement
  du fichier via la fonction <code>eval</code> nécessairement. Or comme le rapelle
  la célèbre expression <q lang="en">eval is evil</q>, cela pose de sérieux problèmes.
  En effet, la fonction <code>eval</code> rend le débogage beaucoup plus compliqué
  puisque le numéro de la ligne et le nom de fichier ayant provoqué l'erreur ne sont
  pas connus, de plus, la fonction <code>eval</code> n'est pas homogène sur tous
  les navigateurs posant des problèmes évidents de compatibilité Cross-Browser.</p>
<p>Il a donc fallu trouver une approche permettant de télécharger chaque fichier Javascript
  de la même manière que le fait le navigateur pour les fichiers Javascript inclus
  directement dans le HTML. Pour cela, l'initiative AMD implémentée dans la très
  célèbre librairie <a hreflang="en title=En savoir plus sur cette librairie bien pratique href=http://requirejs.org"
  />RequireJs</a> utilise un concept bien connu depuis l'avènement d'Ajax.</p>
<p>En effet, RequireJs <a hreflang="en title=Voir le code de RequireJs impliqué href=https://github.com/jrburke/requirejs/blob/master/require.js#L1834">ajoute une balise <script></a>  grâce aux fonctions de manipulation du DOM. Grâce à une fonction de callback, le
  nom, les dépendances et le contenu du module sont déclarés. Les chargements de
  scripts avec fonctions de callback étaient très utilisées pour charger du JSon
  depuis un nom de domaine tiers.</p>
<p>Cette approche permet un chargement asynchrone de toutes les ressources qui sont
  dès lors parallélisées. Le temps de chargement des modules est donc réduit au temps
  de chargement et d'interprétation du dernier fichier Javascript à être totalement
  téléchargé.</p>
<p>L'écriture d'un module AMD se présente comme suit :</p><pre>define('moduleName', [['dep1', 'dep2']], function (dep1, dep2) {<br /> // dep1 et dep2 contiennent les exports réalisés par les modules dont dépend ce même module<br /> // le contenu du module vient ici return function () {}; // Ici, le module exporte via un retour de fonction, les valeurs souhaitées. }); </pre>
<p>On pourrait croire que tout est bien qui fini bien, mais il nous reste un gros problème
  à résoudre. Comment utiliser les modules AMD avec NodeJS et vice-versa ? Il
  <a
  hreflang="en title=Voir les solutions passe-partout existantes href=http://www.2ality.com/2011/11/module-gap.html">existe plusieurs solutions</a> pour rendre inter-compatibles les différents modules,
    mais cela reste une sorte de tambouille incompréhensible. D'ailleurs, je serais
    ravi d'avoir vos bonnes pratiques en la matière.</p>
<p>Edit : On me <a title="Voir la conversation href=https://twitter.com/_Florian_R/status/236437043004207104">souffle dans l'oreille</a>  que require.js est utilisable avec NodeJs, un petit lot de consolation donc ;).</p>
<h3>ECMAScript 6 : La lumière au bout du tunnel</h3>
<p>Grâce à la dernière mouture d'ECMAScript (aussi appelé ECMAScript.next) le standard
  qui sous tend Javascript, un gestionnaire natif de modules Javascript sera disponible.
  Malheureusement, on ne peut faire aucune prévision en ce qui concerne le jour où
  il sera envisageable d'utiliser ce dernier étant donné qu'il faudra que tous les
  principaux navigateurs du marché l'aient implémenté. En ce qui concerne NodeJs,
  étant donné qu'il est basé sur le moteur javascript V8 de Google Chrome, son implémentation
  sera sûrement conditionnée à celle de Google Chrome.</p>
<p>L'approche de la nouvelle version de Javascript est simple, le mot clé export permet
  de déclarer une fonction comme devant être exportée ou d'énumérer les variables
  devant être exportée.</p><pre>var a=1, b=2, c=3;<br /> export a, b, c;<br />export function() {};</pre>
<p>Voilà, vivement que nous puissions enfin utiliser cette version de Javascript et
  résoudre tous nos problèmes de compatibilité de modules. Vos précisions ou commentaires
  sont les bienvenus.</p>