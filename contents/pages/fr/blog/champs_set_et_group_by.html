<!--VarStream
title=Les champs SET et les requêtes GROUP BY
description=J'adore utiliser les champs de type SET pour leur souplesse et leur nature multivaluées, mais quand GROUP BY entre dans la place, attention les dégâts !
shortTitle=A propos de SET & GROUP BY
shortDesc=En savoir plus sur SET & GROUP BY utilisés conjointement
published=2012-08-28T07:34:25.000Z
lang=fr
location=FR
keywords.+=JavaScript
categories.+=.*
-->

<h2>J'adore utiliser les champs de type SET pour leur souplesse et leur nature multivaluées, mais quand GROUP BY entre dans la place, attention les dégâts !</h2>
<p>J'adore utiliser les champs de type SET pour leur souplesse et leur nature multivaluées,
  mais quand GROUP BY entre dans la place, attention les dégâts !</p>

<h3>Petit rappel sur les champs <var>SET</var> dans MySQL</h3>
<p>Si j'aime tant utiliser les champs <var>SET</var> dans mes tables, c'est que contrairement
  aux champs à première vue similaires de type <var>ENUM</var>, ces derniers peuvent
  être multivalués. Imaginons la table suivante permettant de stocker des documents
  techniques, relatifs à des modèles d'équipements, qui peuvent être de plusieurs
  types prédéfinis :</p><pre>CREATE TABLE `documents` (<br /> `id` mediumint(8) unsigned NOT NULL AUTO_INCREMENT,<br /> `label` varchar(75) NOT NULL DEFAULT '',<br /> `model` mediumint(8) unsigned DEFAULT NULL COMMENT 'link:equipmentModels',<br /> `type` <strong>set('standard','law','rule','assemblynotice','washnotice','usenotice','certificate','testreport','implant')</strong> NOT NULL DEFAULT 'law',<br /> `description` text,<br /> `applicationDate` date NOT NULL DEFAULT '0000-00-00',<br /> PRIMARY KEY (`id`),<br /> KEY `model` (`model`),<br /> KEY `applicationDate` (`applicationDate`),<br /> KEY `type` (`type`)<br />) ENGINE=InnoDB DEFAULT CHARSET=utf8 AUTO_INCREMENT=1175 ;</pre>
<p>L'avantage du champs <var>SET</var> est que pour un set prédéfini de valeurs qui
  n'est pas amené à évoluer, on fait l'économie d'une table de jointure qui rendrait
  plus complexe notre schema. Mais ce n'est pas le seul avantage de ce type de champs.
  En effet, les valeurs ne sont pas stockées sous une forme textuelle dans la base
  de donnée, mais sous la forme d'un entier particulier.</p>
<p>Un peu comme pour les droits UNIX, chaque valeurs du champs <var>SET</var> se voit
  assigner en correspondance un entier dont le bit de poids faible indique la <a>itle="Voir la documentation de SET" href="http://dev.mysql.com/doc/refman/5.0/fr/set.html]position dans la liste des valeurs</a>  acceptées par le champs de type SET. Pour notre table, on a donc <var>standard=1, law=2, rule=4, assemblynotice=8, washnotice=16, usenotice=32, certificate=64, testreport=128, implant=256</var>.
  Un champs <var>SET</var> ne peut avoir que 64 valeurs ce qui correspond à la valeur
  maximale d'un entier non signé sur un système 64bits.</p>
<p>Ainsi, si je souhaite obtenir la liste des documents contenant une notice d'utilisation,
  je peux indifféremment utiliser les deux requêtes suivantes :</p><pre>SELECT * FROM `documents` WHERE `type` LIKE '%usenotice%' # ici type est converti en chaîne<br />SELECT * FROM `documents` WHERE `type`&32' # ici type est converti en entier<br />SELECT * FROM `documents` WHERE FIND_IN_SET(`type`,'usenotice')>0 # ici une fonction spécifique aux champs SET est utilisé</pre>
<p>Idéalement, il vaut mieux utiliser la fonction dédiée ou la conversion en chaîne
  car elles sont indépendantes de l'ordre des valeurs dans le champs <var>SET</var>  contrairement à la technique de l'opérateur binaire <var>&</var>. Mais il existe
  un cas où cela peut sauver la vie, c'est ce qui vient de m'arriver pour cette table.</p>
<h3>Et un jour GROUP BY arriva</h3>
<p>Le problème vient quand votre client vous demande si il serait possible de sortir
  une liste des modèles d'équipement pour lesquels certains documents ne sont pas
  présents. La difficulté ici est qu'à un modèle d'équipement peuvent correspondre
  plusieurs lignes de la table <var>documents</var>. Nous avons donc besoin de réunir
  toutes les lignes correspondant au modèle associé et de "merger" les valeurs du
  champs type pour pouvoir y rechercher les valeurs supposées absentes.</p>
<p>Ce fût alors le moment d'utiliser la valeur numérique des champs <var>SET</var>.
  Mon premier réflexe fût d'essayer de coupler la fonction SUM avec l'opérateur binaire
  au sein d'une seule et même requête, mais MySQL n'accepte pas cette forme, j'ai
  donc dû utiliser les requêtes imbriquées, voilà le résultat :</p><pre>SELECT * FROM<br /> (<br /> SELECT organizations.label AS organization, equipmentModels.model AS eqtModel, equipmentModels.reference AS eqtRef,<br /> equipmentModels.description AS eqtDesc, SUM(documents.type) AS docTypesInt, GROUP_CONCAT(documents.type) AS docTypesString<br /> FROM `equipmentModels`<br /> LEFT JOIN documents ON documents.model = equipmentModels.id<br /> LEFT JOIN organizations ON organizations.id = equipmentModels.builder<br /> GROUP BY equipmentModels.id<br /> ORDER BY equipmentModels.builder<br /> ) AS temp<br />WHERE docTypesInt IS NULL<br /> # OR NOT docTypesInt&1 # standard<br /> # OR NOT docTypesInt&2 # law<br /> # OR NOT docTypesInt&4 # rule<br /> OR NOT docTypesInt&8 #assemblynotice<br /> OR NOT docTypesInt&16 #washnotice<br /> OR NOT docTypesInt&32 #usernotice<br /> OR NOT docTypesInt&64 #certificate<br /> # OR NOT docTypesInt&128 #testreport<br /> OR NOT docTypesInt&256 #implant</pre>
<p>Le principe est simple, on fait la somme des valeurs du champs <var>type</var> pour
  toutes les lignes concernant le même équipement (grâce à la clause GROUP BY). Cette
  somme obtenue, on peut utiliser l'opérateur binaire afin de vérifier la présence
  d'une ou plusieurs valeurs au sein de ces champs. la ligne docTypeInt IS NULL sert
  à prendre également en compte le cas où il n'y a aucune valeur de type correspondant
  au modèle.</p>
<p>Le lecteur averti aura remarqué une vaine tentative d'utilisation de la fonction
  <var>GROUP_CONCAT</var> qui aurait peut-être pu servir à continuer d'utiliser une
  comparaison à partir de chaînes, mais le problème est qu'il n'y aura pas de virgule
  insérée entre chaque valeurs du champs <var>type</var>. J'ai cherché après la fonction
  <var>GROUP_CONCAT_WS</var>, mais elle n'existe pas encore.</p>
<p>Bref, les champs SET c'est pratique, mais il faut bien connaître leur nature pour
  pouvoir en profiter pleinement. Et vous, que faîtes vous avec vos <var>SET</var> ?</p>